"""
## Cyclical figurate numbers
Problem 61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:  
Triangle 	  	P3,n=n(n+1)/2 	::  	1, 3, 6, 10, 15, ...  
Square 	  	P4,n=n^2 ::	  	1, 4, 9, 16, 25, ...  
Pentagonal 	  	P5,n=n(3n−1)/2 	::  	1, 5, 12, 22, 35, ...  
Hexagonal 	  	P6,n=n(2n−1) 	::  	1, 6, 15, 28, 45, ...  
Heptagonal 	  	P7,n=n(5n−3)/2 	::  	1, 7, 18, 34, 55, ...  
Octagonal 	  	P8,n=n(3n−2) 	::  	1, 8, 21, 40, 65, ...  

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

- The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
- Each polygonal type: triangle (P(3,127)=8128), square (P(4,91)=8281), and pentagonal (P(5,44)=2882), is represented by a different number in the set.
- This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

Link: https://projecteuler.net/problem=61

Date solved:  
2022/07/29
"""

ANSWER = 28684

# imports

from maths.sequences import *
from maths.math import permutations
from copy import copy

# solution

types = [
    TriangleNumbers(),
    SquareNumbers(),
    PentagonalNumbers(),
    HexagonalNumbers(),
    HeptagonalNumbers(),
    OctagonalNumbers(),
]


def generateCandidates():
    nums = []
    for t in types:
        record = set()
        i = 1
        current = 1
        while current < 1e4:
            if current >= 1e3:
                record.add(str(current))
            i += 1
            current = t[i]

        nums.append(record)
    return nums


def find_path():
    candidates = generateCandidates()

    paths = []
    for order in permutations(range(5)):
        s1 = candidates[5]
        s2 = candidates[order[0]]
        s3 = candidates[order[1]]
        s4 = candidates[order[2]]
        s5 = candidates[order[3]]
        s6 = candidates[order[4]]

        for num1 in s1:
            # TODO: make this recursive
            path = [num1]
            n1_prefix = num1[:2]
            n1_suffix = num1[2:]

            # TODO: refactor with recursion
            for num2 in s2:
                n2_prefix = num2[:2]
                n2_suffix = num2[2:]
                if n2_prefix == n1_suffix:
                    path.append(num2)
                    for num3 in s3:
                        n3_prefix = num3[:2]
                        n3_suffix = num3[2:]
                        if n3_prefix == n2_suffix:
                            path.append(num3)
                            for num4 in s4:
                                n4_prefix = num4[:2]
                                n4_suffix = num4[2:]
                                if n4_prefix == n3_suffix:
                                    path.append(num4)
                                    for num5 in s5:
                                        n5_prefix = num5[:2]
                                        n5_suffix = num5[2:]
                                        if n5_prefix == n4_suffix:
                                            path.append(num5)
                                            for num6 in s6:
                                                n6_prefix = num6[:2]
                                                n6_suffix = num6[2:]
                                                if (n6_prefix == n5_suffix) and (
                                                    n6_suffix == n1_prefix
                                                ):
                                                    path.append(num6)
                                                    paths.append(copy(path))
                                            path.pop(-1)
                                    path.pop(-1)
                            path.pop(-1)
                    path.pop(-1)
    return paths


def solution(bypass=False):
    if bypass:
        return ANSWER

    cycle = find_path()
    return sum(list(map(int, cycle[0])))


if __name__ == "__main__":
    solution(bypass=False)

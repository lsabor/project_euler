"""
## Highly divisible triangular number

Problem 12

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1  
     3: 1,3  
     6: 1,2,3,6  
    10: 1,2,5,10  
    15: 1,3,5,15  
    21: 1,3,7,21  
    28: 1,2,4,7,14,28  

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?


Link: https://projecteuler.net/problem=12

Date solved:  
2022/03/06
"""

ANSWER = 76576500

# TODO: refactor for speed

# imports

from maths.primes import numFromCounter
from maths.sequences import TriangleNumbers
from collections import Counter
from itertools import combinations_with_replacement
from maths.sequences import PrimesSeq


# solution

"""
notes:
the divisor count of n is equal to the product of (exponents+1) of n's prime factorization
we will cycle through different values for ex, removing a prime factor each time,
checking to see if any are triangle numbers
since 2^8 < 500 < 2^9, we'll start by assuming that the number we're looking for will only
have the first 9 prime numbers at most: [2, 3, 5, 7, 11, 13, 17, 19, 23]
let s be the sum of the exponents, we'll start with lowest possible value for s, than inc from there
since prod([2, 3, 5, 7, 11, 13, 17, 19, 23]) is not a triangle number, and 3*2*2*2*2*2*2*2 < 500,
first we'll try with [2, 3, 5, 7, 11, 13, 17] and ex count is 11
"""


def count_divisors(exponents):
    divisors = 1
    for ex in exponents:
        divisors *= 1 + ex
    return divisors


def solution(bypass=False):
    if bypass:
        return ANSWER
    div_min = 500

    T = TriangleNumbers()
    P = PrimesSeq()
    solutions = []

    s = 11
    while True:
        possible_primes = P[: 18 - s]
        for comb in combinations_with_replacement(possible_primes, s - len(possible_primes)):
            pf = Counter(possible_primes) + Counter(comb)
            if count_divisors(pf) <= 500:
                continue
            n = numFromCounter(pf)
            if T.inverseFormula(n) % 1 == 0:
                solutions.append(n)

        if solutions:
            return min(solutions)
        s += 1


if __name__ == "__main__":
    from time import perf_counter

    t0 = perf_counter()
    sol = solution(bypass=False)
    t1 = perf_counter()
    print(f"solution = {sol} in {t1-t0: 0.4f} seconds")
    print("answer   =", ANSWER)
